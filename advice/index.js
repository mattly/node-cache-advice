// Generated by CoffeeScript 1.6.3
(function() {
  var Advice, anyThing, cloneState, del, events, get, isNothing, keyFor, set, setIfThing,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  events = require('events');

  isNothing = function(thing) {
    return thing === null || thing === void 0;
  };

  anyThing = function(things) {
    return things.length > 1 || !isNothing(things[0]);
  };

  keyFor = function() {
    var args, prefix, strategy;
    strategy = arguments[0], prefix = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return "" + (prefix || '') + (strategy.apply(null, args));
  };

  setIfThing = function(cache, key, callback) {
    return function() {
      var err, result;
      err = arguments[0], result = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (!err && anyThing(result)) {
        set(cache, key, result);
      }
      return callback.apply(null, [err].concat(__slice.call(result)));
    };
  };

  get = function(cache, key, cb) {
    return cache.get(key, cb);
  };

  set = function(cache, key, val, cb) {
    var done;
    done = function(err, result) {
      return typeof cb === "function" ? cb() : void 0;
    };
    return cache.set(key, val, done);
  };

  del = function(cache, key, cb) {
    var done;
    done = function(err, result) {
      return typeof cb === "function" ? cb() : void 0;
    };
    return cache.del(key, done);
  };

  cloneState = function(previous, next) {
    var key, value;
    for (key in previous) {
      if (!__hasProp.call(previous, key)) continue;
      value = previous[key];
      if (!next[key]) {
        next[key] = value;
      }
    }
    return next;
  };

  Advice = (function(_super) {
    __extends(Advice, _super);

    function Advice(state) {
      var _base, _base1;
      this.state = state;
      Advice.__super__.constructor.call(this);
      (_base = this.state).keyStrategy || (_base.keyStrategy = function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return args.join();
      });
      (_base1 = this.state).cache || (_base1.cache = require('./lru')(this.state.lru));
      this.cache = this.state.cache;
    }

    Advice.prototype.prefix = function(prefix) {
      if (prefix) {
        return new Advice(cloneState(this.state, {
          prefix: prefix
        }));
      } else {
        return this.state.prefix;
      }
    };

    Advice.prototype.appendPrefix = function(prefix) {
      return new Advice(cloneState(this.state, {
        prefix: "" + this.state.prefix + prefix
      }));
    };

    Advice.prototype.keyStrategy = function(keyStrategy) {
      if (keyStrategy) {
        return new Advice(cloneState(this.state, {
          keyStrategy: keyStrategy
        }));
      } else {
        return this.state.keyStrategy;
      }
    };

    Advice.prototype.updates = function(fn) {
      var cache, keyStrategy, prefix, _ref;
      _ref = this.state, cache = _ref.cache, keyStrategy = _ref.keyStrategy, prefix = _ref.prefix;
      return function() {
        var args, callback, key, _i;
        args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
        key = keyFor.apply(null, [keyStrategy, prefix].concat(__slice.call(args)));
        return fn.apply(null, __slice.call(args).concat([setIfThing(cache, key, callback)]));
      };
    };

    Advice.prototype.readThrough = function(fn) {
      var cache, keyStrategy, prefix, _ref;
      _ref = this.state, cache = _ref.cache, keyStrategy = _ref.keyStrategy, prefix = _ref.prefix;
      return function() {
        var args, callback, handleCache, key, _i;
        args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
        key = keyFor.apply(null, [keyStrategy, prefix].concat(__slice.call(args)));
        handleCache = function(err, result) {
          if (!isNothing(result)) {
            return callback.apply(null, [void 0].concat(__slice.call(result)));
          } else {
            return fn.apply(null, __slice.call(args).concat([setIfThing(cache, key, callback)]));
          }
        };
        return get(cache, key, handleCache);
      };
    };

    Advice.prototype.expires = function(fn) {
      var cache, keyStrategy, prefix, _ref;
      _ref = this.state, cache = _ref.cache, keyStrategy = _ref.keyStrategy, prefix = _ref.prefix;
      return function() {
        var args, callback, key, _i;
        args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
        key = keyFor.apply(null, [keyStrategy, prefix].concat(__slice.call(args)));
        del(cache, key);
        return fn.apply(null, __slice.call(args).concat([callback]));
      };
    };

    return Advice;

  })(events.EventEmitter);

  module.exports = function(config) {
    if (config == null) {
      config = {};
    }
    return new Advice(config);
  };

}).call(this);
