// Generated by CoffeeScript 1.6.1
(function() {
  var events,
    __slice = [].slice;

  events = require('events');

  module.exports = function(config) {
    var advice, cache, defaultKeyMaker, errNotifier, get, set, shouldStore;
    if (config == null) {
      config = {};
    }
    if (config.cache) {
      cache = config.cache;
    } else {
      cache = require('./lru')(config.lru);
    }
    defaultKeyMaker = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return "" + args[0];
    };
    shouldStore = function(args) {
      var arg, store, _i, _len;
      store = false;
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        arg = args[_i];
        if (arg) {
          store = true;
        }
      }
      return store;
    };
    advice = new events.EventEmitter();
    advice.cache = cache;
    advice.shouldStore = shouldStore;
    errNotifier = function(callback) {
      return function(err, result) {
        if (err) {
          advice.emit('error', err);
        }
        return typeof callback === "function" ? callback(err, result) : void 0;
      };
    };
    get = function(key, callback) {
      return advice.cache.get(key, errNotifier(callback));
    };
    set = function(key, value, callback) {
      return advice.cache.set(key, value, errNotifier(callback));
    };
    advice.set = function(fn, keymaker) {
      keymaker || (keymaker = defaultKeyMaker);
      return function() {
        var args, callback, key, _i;
        args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
        key = keymaker.apply(null, args);
        return fn.apply(null, __slice.call(args).concat([function() {
          var err, result;
          err = arguments[0], result = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (err) {
            return callback.apply(null, [err].concat(__slice.call(result)));
          }
          if (advice.shouldStore(result)) {
            set(key, result);
          }
          return callback.apply(null, [err].concat(__slice.call(result)));
        }]));
      };
    };
    advice.get = function(fn, keymaker) {
      keymaker || (keymaker = defaultKeyMaker);
      return function() {
        var args, callback, key, _i;
        args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
        key = keymaker.apply(null, args);
        return get(key, function(err, result) {
          if (result) {
            return callback.apply(null, [void 0].concat(__slice.call(result)));
          }
          return fn.apply(null, __slice.call(args).concat([callback]));
        });
      };
    };
    advice.readThrough = function(fn, keymaker) {
      keymaker || (keymaker = defaultKeyMaker);
      return function() {
        var args, callback, key, _i;
        args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
        key = keymaker.apply(null, args);
        return get(key, function(err, result) {
          if (result) {
            return callback.apply(null, [void 0].concat(__slice.call(result)));
          }
          return fn.apply(null, __slice.call(args).concat([function() {
            var err, result;
            err = arguments[0], result = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            if (err) {
              return callback.apply(null, [err].concat(__slice.call(result)));
            }
            if (advice.shouldStore(result)) {
              set(key, result);
            }
            return callback.apply(null, [err].concat(__slice.call(result)));
          }]));
        });
      };
    };
    advice.del = function(fn, keymaker) {
      keymaker || (keymaker = defaultKeyMaker);
      return function() {
        var args, callback, key, _i;
        args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
        key = keymaker.apply(null, args);
        return fn.apply(null, __slice.call(args).concat([function() {
          var err, result;
          err = arguments[0], result = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (err) {
            return callback.apply(null, [err].concat(__slice.call(result)));
          }
          cache.del(key, errNotifier());
          return callback.apply(null, [err].concat(__slice.call(result)));
        }]));
      };
    };
    return advice;
  };

}).call(this);
