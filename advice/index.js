// Generated by CoffeeScript 1.6.1
(function() {
  var events,
    __slice = [].slice;

  events = require('events');

  module.exports = function(config) {
    var advice, cache, defaultKeyMaker, error, shouldStore;
    if (config == null) {
      config = {};
    }
    if (config.cache) {
      cache = config.cache;
    } else {
      cache = require('./lru')(config.lru);
    }
    defaultKeyMaker = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return "" + args[0];
    };
    shouldStore = function(args) {
      var arg, store, _i, _len;
      store = false;
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        arg = args[_i];
        if (arg) {
          store = true;
        }
      }
      return store;
    };
    advice = new events.EventEmitter();
    error = function(err) {
      if (err) {
        return advice.emit('error', err);
      }
    };
    advice.cache = cache;
    advice.shouldStore = shouldStore;
    advice.set = function(fn, keymaker) {
      keymaker || (keymaker = defaultKeyMaker);
      return function() {
        var args, callback, key, _i;
        args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
        key = keymaker.apply(null, args);
        return fn.apply(null, __slice.call(args).concat([function() {
          var err, result;
          err = arguments[0], result = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (err) {
            return callback.apply(null, [err].concat(__slice.call(result)));
          }
          if (advice.shouldStore(result)) {
            cache.set(key, result, function(err) {});
          }
          return callback.apply(null, [err].concat(__slice.call(result)));
        }]));
      };
    };
    advice.get = function(fn, keymaker) {
      keymaker || (keymaker = defaultKeyMaker);
      return function() {
        var args, callback, key, _i;
        args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
        key = keymaker.apply(null, args);
        return cache.get(key, function(err, result) {
          error(err);
          if (result) {
            return callback.apply(null, [err].concat(__slice.call(result)));
          }
          return fn.apply(null, __slice.call(args).concat([callback]));
        });
      };
    };
    advice.del = function(fn, keymaker) {
      keymaker || (keymaker = defaultKeyMaker);
      return function() {
        var args, callback, key, _i;
        args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
        key = keymaker.apply(null, args);
        return fn.apply(null, __slice.call(args).concat([function() {
          var err, result;
          err = arguments[0], result = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (err) {
            return callback.apply(null, [err].concat(__slice.call(result)));
          }
          cache.del(key, error);
          return callback.apply(null, [err].concat(__slice.call(result)));
        }]));
      };
    };
    return advice;
  };

}).call(this);
